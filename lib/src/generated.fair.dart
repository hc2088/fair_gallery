// GENERATED CODE - DO NOT MODIFY MANUALLY
// **************************************************************************
// But you can define a new GeneratedModule as following:
// class MyAppGeneratedModule extends AppGeneratedModule {
//   @override
//   Map<String, dynamic> components() {
//     return <String, dynamic>{
//       ...super.components(),
//      // add your cases here.
//     };
//   }
//
//   /// true means it's a widget.
//   @override
//   Map<String, bool> mapping() {
//     return <String, bool>{
//       ...super.mapping(),
//       // remember add your cases here too.
//     };
//   }
// }
// **************************************************************************
// Auto generated by https://github.com/wuba/Fair
// **************************************************************************
//
// ignore_for_file: implementation_imports, unused_import, depend_on_referenced_packages, unused_shown_name, duplicate_import, always_specify_types, unnecessary_import

import 'package:extended_image/extended_image.dart';
import 'package:extended_sliver/extended_sliver.dart';
import 'package:extended_text/extended_text.dart';
import 'package:keframe/keframe.dart';
import 'package:like_button/like_button.dart';
import 'package:loading_more_list/loading_more_list.dart';
import 'package:oktoast/oktoast.dart';
import 'package:pull_to_refresh_notification/pull_to_refresh_notification.dart';
import 'package:fair_gallery/src/sugar/common.dart';
import 'package:fair_gallery/src/sugar/dart_core.dart';
import 'package:fair_gallery/src/sugar/extension.dart';
import 'package:fair_gallery/assets.dart';
import 'package:fair_gallery/src/widget/extended_fair_widget.dart';
import 'package:fair_gallery/src/widget/share_data_widget.dart';
import 'package:fair_gallery/src/widget/push_to_refresh_header.dart';
import 'package:fair_gallery/src/widget/hero_widget.dart';
import 'package:fair_gallery/src/widget/image_grid.dart';
import 'package:loading_more_list_library/loading_more_list_library.dart';
import 'package:fair_gallery/src/utils/repository.dart';
import 'package:fair_gallery/src/widget/frame_separate_widget.dart';
import 'package:extended_image_library/extended_image_library.dart';
import 'package:extended_image/src/border_painter.dart';
import 'package:extended_image/src/editor/editor.dart';
import 'package:extended_image/src/editor/editor_utils.dart';
import 'package:extended_image/src/extended_image.dart';
import 'package:extended_image/src/gesture/gesture.dart';
import 'package:extended_image/src/gesture/page_view/gesture_page_view.dart';
import 'package:extended_image/src/gesture/slide_page.dart';
import 'package:extended_image/src/gesture/slide_page_handler.dart';
import 'package:extended_image/src/gesture/utils.dart';
import 'package:extended_image/src/image/painting.dart';
import 'package:extended_image/src/image/raw_image.dart';
import 'package:extended_image/src/image/render_image.dart';
import 'package:extended_image/src/typedef.dart';
import 'package:extended_image/src/utils.dart';
import 'package:extended_sliver/src/widget.dart';
import 'package:extended_text_library/extended_text_library.dart';
import 'package:extended_text/src/extended_render_paragraph.dart';
import 'package:extended_text/src/extended_text.dart';
import 'package:extended_text/src/selection/extended_text_selection.dart';
import 'package:extended_text/src/selection/extended_text_selection_pointer_handler.dart';
import 'package:extended_text/src/text_overflow_widget.dart';
import 'package:keframe/src/frame_separate_task.dart';
import 'package:keframe/src/frame_separate_widget.dart';
import 'package:keframe/src/layout_proxy.dart';
import 'package:keframe/src/logcat.dart';
import 'package:keframe/src/notification.dart';
import 'package:keframe/src/size_cache_widget.dart';
import 'package:like_button/src/like_button.dart';
import 'package:like_button/src/utils/like_button_model.dart';
import 'package:like_button/src/utils/like_button_typedef.dart';
import 'package:extended_list_library/extended_list_library.dart';
import 'package:waterfall_flow/waterfall_flow.dart';
import 'package:loading_more_list/src/empty_widget.dart';
import 'package:loading_more_list/src/glow_notification_widget.dart';
import 'package:loading_more_list/src/indicator_widget.dart';
import 'package:loading_more_list/src/list_config/list_config.dart';
import 'package:loading_more_list/src/list_config/loading_more_list_config.dart';
import 'package:loading_more_list/src/list_config/sliver_list_config.dart';
import 'package:loading_more_list/src/loading_more_list.dart';
import 'package:loading_more_list/src/loading_more_sliver_list.dart';
import 'package:loading_more_list/src/physics.dart';
import 'package:oktoast/src/core/position.dart';
import 'package:oktoast/src/core/toast.dart';
import 'package:oktoast/src/widget/animation/animation_builder.dart';
import 'package:oktoast/src/widget/animation/offset_builder.dart';
import 'package:oktoast/src/widget/animation/opacity_builder.dart';
import 'package:pull_to_refresh_notification/src/always_scrollable_clamping_scroll_physics.dart';
import 'package:pull_to_refresh_notification/src/pull_to_refresh_notification.dart';
import 'package:loading_more_list_library/src/loading_more_list_library.dart';
import 'dart:math';
import 'package:fair/fair.dart';
import 'package:flutter/material.dart';
import 'package:fair_gallery/src/extension/string.dart';
import 'dart:convert';
import 'package:fair_gallery/src/utils/asset_buldes.dart';
import 'package:ff_annotation_route_library/ff_annotation_route_library.dart';
import 'dart:ui' as ui show Image;
import 'package:intl/intl.dart';
import 'dart:async';
import 'package:fair_gallery/src/plugin/completer.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/rendering.dart';
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:flutter/gestures.dart';
import 'package:flutter/widgets.dart';
import 'package:extended_image/src/editor/crop_layer.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart' hide Image;
import 'package:flutter/semantics.dart';
import 'package:extended_image/src/gesture_detector/drag.dart';
import 'package:extended_sliver/src/element.dart';
import 'package:extended_sliver/src/rendering.dart';
import 'dart:collection';
import 'dart:math' as math;
import 'dart:ui' as ui
    show
        Gradient,
        Shader,
        TextBox,
        TextHeightBehavior,
        BoxWidthStyle,
        BoxHeightStyle;
import 'dart:ui';
import 'dart:ui' as ui show TextHeightBehavior, BoxWidthStyle, BoxHeightStyle;
import 'package:extended_text/src/extended_rich_text.dart';
import 'package:flutter/services.dart';
import 'package:extended_text/src/extended_text_typedef.dart';
import 'dart:developer';
import 'package:like_button/src/painter/bubbles_painter.dart';
import 'package:like_button/src/painter/circle_painter.dart';
import 'package:like_button/src/utils/like_button_util.dart';
import 'package:extended_list/extended_list.dart';
import 'package:flutter/material.dart' hide Overlay, OverlayEntry, OverlayState;
import 'package:oktoast/src/widget/overlay.dart';
import 'package:oktoast/src/core/toast_manager.dart';
import 'package:flutter/cupertino.dart' show CupertinoDynamicColor;
import 'package:meta/meta.dart';

import 'package:flutter/material.dart';
import 'package:fair/fair.dart';
import 'package:fair_version/fair_version.dart';

class AppGeneratedModule extends GeneratedModule {
  @override
  Map<String, dynamic> components() {
    return {
      'PullToRefreshNotification': (props) => PullToRefreshNotification(
            key: props['key'],
            child: props['child'],
            onRefresh: props['onRefresh'],
            color: props['color'],
            pullBackOnRefresh: props['pullBackOnRefresh'] ?? false,
            maxDragOffset: props['maxDragOffset']?.toDouble(),
            notificationPredicate:
                props['notificationPredicate'] ?? defaultNotificationPredicate,
            armedDragUpCancel: props['armedDragUpCancel'] ?? true,
            pullBackCurve: props['pullBackCurve'] ?? Curves.linear,
            reverse: props['reverse'] ?? false,
            pullBackOnError: props['pullBackOnError'] ?? false,
            pullBackDuration:
                props['pullBackDuration'] ?? const Duration(milliseconds: 400),
            refreshOffset: props['refreshOffset']?.toDouble(),
            reachToRefreshOffset: props['reachToRefreshOffset']?.toDouble(),
          ),
      'PullToRefreshContainer': (props) => PullToRefreshContainer(
            props['pa'][0],
          ),
      'PullToRefreshCupertinoActivityIndicator': (props) =>
          PullToRefreshCupertinoActivityIndicator(
            key: props['key'],
            animating: props['animating'] ?? true,
            radius: props['radius']?.toDouble() ??
                PullToRefreshCupertinoActivityIndicator.defaultIndicatorRadius,
            activeColor: props['activeColor'],
          ),
      'PullToRefreshCupertinoActivityIndicator.defaultIndicatorRadius':
          PullToRefreshCupertinoActivityIndicator.defaultIndicatorRadius,
      'PullToRefreshIndicatorMode': {
        'drag': PullToRefreshIndicatorMode.drag,
        'armed': PullToRefreshIndicatorMode.armed,
        'snap': PullToRefreshIndicatorMode.snap,
        'refresh': PullToRefreshIndicatorMode.refresh,
        'done': PullToRefreshIndicatorMode.done,
        'canceled': PullToRefreshIndicatorMode.canceled,
        'error': PullToRefreshIndicatorMode.error,
        'values': PullToRefreshIndicatorMode.values,
      },
      'TextOverflowWidget': (props) => TextOverflowWidget(
            child: props['child'],
            align: props['align'] ?? TextOverflowAlign.right,
            maxHeight: props['maxHeight']?.toDouble(),
            position: props['position'] ?? TextOverflowPosition.end,
            debugOverflowRectColor: props['debugOverflowRectColor'],
            clearType:
                props['clearType'] ?? TextOverflowClearType.blendModeClear,
          ),
      'TextOverflowAlign': {
        'left': TextOverflowAlign.left,
        'right': TextOverflowAlign.right,
        'center': TextOverflowAlign.center,
        'values': TextOverflowAlign.values,
      },
      'TextOverflowPosition': {
        'start': TextOverflowPosition.start,
        'middle': TextOverflowPosition.middle,
        'end': TextOverflowPosition.end,
        'values': TextOverflowPosition.values,
      },
      'TextOverflowClearType': {
        'clipRect': TextOverflowClearType.clipRect,
        'blendModeClear': TextOverflowClearType.blendModeClear,
        'values': TextOverflowClearType.values,
      },
      'ExtendedText': (props) => ExtendedText(
            props['pa'][0],
            key: props['key'],
            style: props['style'],
            strutStyle: props['strutStyle'],
            textAlign: props['textAlign'],
            textDirection: props['textDirection'],
            locale: props['locale'],
            softWrap: props['softWrap'],
            overflow: props['overflow'],
            textScaleFactor: props['textScaleFactor']?.toDouble(),
            maxLines: props['maxLines'],
            semanticsLabel: props['semanticsLabel'],
            textWidthBasis: props['textWidthBasis'],
            textHeightBehavior: props['textHeightBehavior'],
            specialTextSpanBuilder: props['specialTextSpanBuilder'],
            onSpecialTextTap: props['onSpecialTextTap'],
            selectionEnabled: props['selectionEnabled'] ?? false,
            onTap: props['onTap'],
            selectionColor: props['selectionColor'],
            dragStartBehavior:
                props['dragStartBehavior'] ?? DragStartBehavior.start,
            selectionControls: props['selectionControls'],
            selectionHeightStyle:
                props['selectionHeightStyle'] ?? ui.BoxHeightStyle.tight,
            selectionWidthStyle:
                props['selectionWidthStyle'] ?? ui.BoxWidthStyle.tight,
            overflowWidget: props['overflowWidget'],
            joinZeroWidthSpace: props['joinZeroWidthSpace'] ?? false,
            shouldShowSelectionHandles: props['shouldShowSelectionHandles'],
            textSelectionGestureDetectorBuilder:
                props['textSelectionGestureDetectorBuilder'],
          ),
      'ExtendedText.rich': (props) => ExtendedText.rich(
            props['pa'][0],
            key: props['key'],
            style: props['style'],
            strutStyle: props['strutStyle'],
            textAlign: props['textAlign'],
            textDirection: props['textDirection'],
            locale: props['locale'],
            softWrap: props['softWrap'],
            overflow: props['overflow'],
            textScaleFactor: props['textScaleFactor']?.toDouble(),
            maxLines: props['maxLines'],
            semanticsLabel: props['semanticsLabel'],
            textWidthBasis: props['textWidthBasis'],
            textHeightBehavior: props['textHeightBehavior'],
            onSpecialTextTap: props['onSpecialTextTap'],
            selectionEnabled: props['selectionEnabled'] ?? false,
            onTap: props['onTap'],
            selectionColor: props['selectionColor'],
            dragStartBehavior:
                props['dragStartBehavior'] ?? DragStartBehavior.start,
            selectionControls: props['selectionControls'],
            selectionHeightStyle:
                props['selectionHeightStyle'] ?? ui.BoxHeightStyle.tight,
            selectionWidthStyle:
                props['selectionWidthStyle'] ?? ui.BoxWidthStyle.tight,
            overflowWidget: props['overflowWidget'],
            joinZeroWidthSpace: props['joinZeroWidthSpace'] ?? false,
            shouldShowSelectionHandles: props['shouldShowSelectionHandles'],
            textSelectionGestureDetectorBuilder:
                props['textSelectionGestureDetectorBuilder'],
          ),
      'ExtendedTextSelection': (props) => ExtendedTextSelection(
            onTap: props['onTap'],
            softWrap: props['softWrap'],
            locale: props['locale'],
            textDirection: props['textDirection'],
            textAlign: props['textAlign'],
            maxLines: props['maxLines'],
            textScaleFactor: props['textScaleFactor']?.toDouble(),
            overflow: props['overflow'],
            text: props['text'],
            selectionColor: props['selectionColor'],
            dragStartBehavior:
                props['dragStartBehavior'] ?? DragStartBehavior.start,
            data: props['data'],
            textSelectionControls: props['textSelectionControls'],
            textWidthBasis: props['textWidthBasis'],
            textHeightBehavior: props['textHeightBehavior'],
            selectionHeightStyle:
                props['selectionHeightStyle'] ?? BoxHeightStyle.tight,
            selectionWidthStyle:
                props['selectionWidthStyle'] ?? BoxWidthStyle.tight,
            overFlowWidget: props['overFlowWidget'],
            strutStyle: props['strutStyle'],
            shouldShowSelectionHandles: props['shouldShowSelectionHandles'],
            textSelectionGestureDetectorBuilder:
                props['textSelectionGestureDetectorBuilder'],
            key: props['key'],
          ),
      'ExtendedTextSelectionPointerHandler': (props) =>
          ExtendedTextSelectionPointerHandler(
            child: props['child'],
            builder: props['builder'],
          ),
      'Assets': {
        'assets_fair_lib_src_page_list_builder_fair_bin':
            Assets.assets_fair_lib_src_page_list_builder_fair_bin,
        'assets_fair_lib_src_page_list_builder_fair_js':
            Assets.assets_fair_lib_src_page_list_builder_fair_js,
        'assets_fair_lib_src_page_photo_gallery_fair_bin':
            Assets.assets_fair_lib_src_page_photo_gallery_fair_bin,
        'assets_fair_lib_src_page_photo_gallery_fair_js':
            Assets.assets_fair_lib_src_page_photo_gallery_fair_js,
        'assets_fair_lib_src_page_photo_gallery1_fair_bin':
            Assets.assets_fair_lib_src_page_photo_gallery1_fair_bin,
        'assets_fair_lib_src_page_photo_gallery1_fair_js':
            Assets.assets_fair_lib_src_page_photo_gallery1_fair_js,
        'assets_fair_lib_src_page_photo_gallery_item_fair_bin':
            Assets.assets_fair_lib_src_page_photo_gallery_item_fair_bin,
        'assets_fair_lib_src_page_photo_gallery_item_fair_js':
            Assets.assets_fair_lib_src_page_photo_gallery_item_fair_js,
        'assets_fair_lib_src_page_photo_swiper_fair_bin':
            Assets.assets_fair_lib_src_page_photo_swiper_fair_bin,
        'assets_fair_lib_src_page_photo_swiper_fair_js':
            Assets.assets_fair_lib_src_page_photo_swiper_fair_js,
        'assets_image_40_png': Assets.assets_image_40_png,
        'assets_image_avatar_jpg': Assets.assets_image_avatar_jpg,
        'assets_image_fluttercandies_grey_png':
            Assets.assets_image_fluttercandies_grey_png,
        'assets_image_loading_gif': Assets.assets_image_loading_gif,
        'assets_image_love_png': Assets.assets_image_love_png,
        'assets_image_sun_glasses_png': Assets.assets_image_sun_glasses_png,
        'assets_plugin_fair_common_plugin_js':
            Assets.assets_plugin_fair_common_plugin_js,
      },
      'SugarIterable.iterator': (props) => SugarIterable.iterator(
            props['pa'][0],
          ),
      'SugarIterable.length': (props) => SugarIterable.length(
            props['pa'][0],
          ),
      'SugarIterable.isEmpty': (props) => SugarIterable.isEmpty(
            props['pa'][0],
          ),
      'SugarIterable.isNotEmpty': (props) => SugarIterable.isNotEmpty(
            props['pa'][0],
          ),
      'SugarIterable.first': (props) => SugarIterable.first(
            props['pa'][0],
          ),
      'SugarIterable.last': (props) => SugarIterable.last(
            props['pa'][0],
          ),
      'SugarIterable.single': (props) => SugarIterable.single(
            props['pa'][0],
          ),
      'SugarIterable.castFrom': (props) => SugarIterable.castFrom(
            props['pa'][0],
          ),
      'SugarIterable.cast': (props) => SugarIterable.cast(
            props['pa'][0],
          ),
      'SugarIterable.followedBy': (props) => SugarIterable.followedBy(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.map': (props) => SugarIterable.map(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.where': (props) => SugarIterable.where(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.whereType': (props) => SugarIterable.whereType(
            props['pa'][0],
          ),
      'SugarIterable.expand': (props) => SugarIterable.expand(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.contains': (props) => SugarIterable.contains(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.forEach': (props) => SugarIterable.forEach(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.reduce': (props) => SugarIterable.reduce(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.fold': (props) => SugarIterable.fold(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarIterable.every': (props) => SugarIterable.every(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.join': (props) => SugarIterable.join(
            props['pa'][0],
            props['pa'][1] ?? "",
          ),
      'SugarIterable.any': (props) => SugarIterable.any(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.toList': (props) => SugarIterable.toList(
            props['pa'][0],
            growable: props['growable'] ?? true,
          ),
      'SugarIterable.toSet': (props) => SugarIterable.toSet(
            props['pa'][0],
          ),
      'SugarIterable.take': (props) => SugarIterable.take(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.takeWhile': (props) => SugarIterable.takeWhile(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.skip': (props) => SugarIterable.skip(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.skipWhile': (props) => SugarIterable.skipWhile(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.firstWhere': (props) => SugarIterable.firstWhere(
            props['pa'][0],
            props['pa'][1],
            orElse: props['orElse'],
          ),
      'SugarIterable.lastWhere': (props) => SugarIterable.lastWhere(
            props['pa'][0],
            props['pa'][1],
            orElse: props['orElse'],
          ),
      'SugarIterable.singleWhere': (props) => SugarIterable.singleWhere(
            props['pa'][0],
            props['pa'][1],
            orElse: props['orElse'],
          ),
      'SugarIterable.elementAt': (props) => SugarIterable.elementAt(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarIterable.iterableToString': (props) =>
          SugarIterable.iterableToString(
            props['pa'][0],
          ),
      'SugarMap.entries': (props) => SugarMap.entries(
            props['pa'][0],
          ),
      'SugarMap.keys': (props) => SugarMap.keys(
            props['pa'][0],
          ),
      'SugarMap.values': (props) => SugarMap.values(
            props['pa'][0],
          ),
      'SugarMap.length': (props) => SugarMap.length(
            props['pa'][0],
          ),
      'SugarMap.isEmpty': (props) => SugarMap.isEmpty(
            props['pa'][0],
          ),
      'SugarMap.isNotEmpty': (props) => SugarMap.isNotEmpty(
            props['pa'][0],
          ),
      'SugarMap.containsValue': (props) => SugarMap.containsValue(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.containsKey': (props) => SugarMap.containsKey(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.get': (props) => SugarMap.get(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.set': (props) => SugarMap.set(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarMap.addEntries': (props) => SugarMap.addEntries(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.update': (props) => SugarMap.update(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            ifAbsent: props['ifAbsent'],
          ),
      'SugarMap.updateAll': (props) => SugarMap.updateAll(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.removeWhere': (props) => SugarMap.removeWhere(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.putIfAbsent': (props) => SugarMap.putIfAbsent(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarMap.addAll': (props) => SugarMap.addAll(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.remove': (props) => SugarMap.remove(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarMap.clear': (props) => SugarMap.clear(
            props['pa'][0],
          ),
      'SugarMap.forEach': (props) => SugarMap.forEach(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarBool.and': (props) => SugarBool.and(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarBool.inclusiveOr': (props) => SugarBool.inclusiveOr(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarBool.exclusiveOr': (props) => SugarBool.exclusiveOr(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarBool.boolToString': (props) => SugarBool.boolToString(
            props['pa'][0],
          ),
      'SugarDouble.nan': (props) => SugarDouble.nan(),
      'SugarDouble.infinity': (props) => SugarDouble.infinity(),
      'SugarDouble.negativeInfinity': (props) => SugarDouble.negativeInfinity(),
      'SugarDouble.minPositive': (props) => SugarDouble.minPositive(),
      'SugarDouble.maxFinite': (props) => SugarDouble.maxFinite(),
      'SugarDouble.sign': (props) => SugarDouble.sign(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.remainder': (props) => SugarDouble.remainder(
            props['pa'][0]?.toDouble(),
            props['pa'][1],
          ),
      'SugarDouble.adds': (props) => SugarDouble.adds(
            props['pa'][0]?.toDouble(),
            props['pa'][1],
          ),
      'SugarDouble.subtracts': (props) => SugarDouble.subtracts(
            props['pa'][0]?.toDouble(),
            props['pa'][1],
          ),
      'SugarDouble.multiplies': (props) => SugarDouble.multiplies(
            props['pa'][0]?.toDouble(),
            props['pa'][1],
          ),
      'SugarDouble.euclideanModulo': (props) => SugarDouble.euclideanModulo(
            props['pa'][0]?.toDouble(),
            props['pa'][1],
          ),
      'SugarDouble.divides': (props) => SugarDouble.divides(
            props['pa'][0]?.toDouble(),
            props['pa'][1],
          ),
      'SugarDouble.truncatingDivision': (props) =>
          SugarDouble.truncatingDivision(
            props['pa'][0]?.toDouble(),
            props['pa'][1],
          ),
      'SugarDouble.negation': (props) => SugarDouble.negation(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.abs': (props) => SugarDouble.abs(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.round': (props) => SugarDouble.round(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.floor': (props) => SugarDouble.floor(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.ceil': (props) => SugarDouble.ceil(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.truncate': (props) => SugarDouble.truncate(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.roundToDouble': (props) => SugarDouble.roundToDouble(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.floorToDouble': (props) => SugarDouble.floorToDouble(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.ceilToDouble': (props) => SugarDouble.ceilToDouble(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.truncateToDouble': (props) => SugarDouble.truncateToDouble(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.doubleToString': (props) => SugarDouble.doubleToString(
            props['pa'][0]?.toDouble(),
          ),
      'SugarDouble.parse': (props) => SugarDouble.parse(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarDouble.tryParse': (props) => SugarDouble.tryParse(
            props['pa'][0],
          ),
      'SugarInt.isEven': (props) => SugarInt.isEven(
            props['pa'][0],
          ),
      'SugarInt.isOdd': (props) => SugarInt.isOdd(
            props['pa'][0],
          ),
      'SugarInt.bitLength': (props) => SugarInt.bitLength(
            props['pa'][0],
          ),
      'SugarInt.sign': (props) => SugarInt.sign(
            props['pa'][0],
          ),
      'SugarInt.and': (props) => SugarInt.and(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.or': (props) => SugarInt.or(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.exclusiveOr': (props) => SugarInt.exclusiveOr(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.negate': (props) => SugarInt.negate(
            props['pa'][0],
          ),
      'SugarInt.leftShift': (props) => SugarInt.leftShift(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.rightShift': (props) => SugarInt.rightShift(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.unsignedRightShift': (props) => SugarInt.unsignedRightShift(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.modPow': (props) => SugarInt.modPow(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarInt.modInverse': (props) => SugarInt.modInverse(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.gcd': (props) => SugarInt.gcd(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.toUnsigned': (props) => SugarInt.toUnsigned(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.toSigned': (props) => SugarInt.toSigned(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.negation': (props) => SugarInt.negation(
            props['pa'][0],
          ),
      'SugarInt.abs': (props) => SugarInt.abs(
            props['pa'][0],
          ),
      'SugarInt.round': (props) => SugarInt.round(
            props['pa'][0],
          ),
      'SugarInt.floor': (props) => SugarInt.floor(
            props['pa'][0],
          ),
      'SugarInt.ceil': (props) => SugarInt.ceil(
            props['pa'][0],
          ),
      'SugarInt.truncate': (props) => SugarInt.truncate(
            props['pa'][0],
          ),
      'SugarInt.roundToDouble': (props) => SugarInt.roundToDouble(
            props['pa'][0],
          ),
      'SugarInt.floorToDouble': (props) => SugarInt.floorToDouble(
            props['pa'][0],
          ),
      'SugarInt.ceilToDouble': (props) => SugarInt.ceilToDouble(
            props['pa'][0],
          ),
      'SugarInt.truncateToDouble': (props) => SugarInt.truncateToDouble(
            props['pa'][0],
          ),
      'SugarInt.intToString': (props) => SugarInt.intToString(
            props['pa'][0],
          ),
      'SugarInt.toRadixString': (props) => SugarInt.toRadixString(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarInt.parse': (props) => SugarInt.parse(
            props['pa'][0],
            radix: props['radix'],
            onError: props['onError'],
          ),
      'SugarInt.tryParse': (props) => SugarInt.tryParse(
            props['pa'][0],
            radix: props['radix'],
          ),
      'SugarList.length': (props) => SugarList.length(
            props['pa'][0],
          ),
      'SugarList.reversed': (props) => SugarList.reversed(
            props['pa'][0],
          ),
      'SugarList.castFrom': (props) => SugarList.castFrom(
            props['pa'][0],
          ),
      'SugarList.copyRange': (props) => SugarList.copyRange(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            props['pa'][3],
            props['pa'][4],
          ),
      'SugarList.writeIterable': (props) => SugarList.writeIterable(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.cast': (props) => SugarList.cast(
            props['pa'][0],
          ),
      'SugarList.get': (props) => SugarList.get(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.set': (props) => SugarList.set(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.add': (props) => SugarList.add(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.addAll': (props) => SugarList.addAll(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.sort': (props) => SugarList.sort(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.shuffle': (props) => SugarList.shuffle(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.indexOf': (props) => SugarList.indexOf(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarList.indexWhere': (props) => SugarList.indexWhere(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarList.lastIndexWhere': (props) => SugarList.lastIndexWhere(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarList.lastIndexOf': (props) => SugarList.lastIndexOf(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarList.clear': (props) => SugarList.clear(
            props['pa'][0],
          ),
      'SugarList.insert': (props) => SugarList.insert(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.insertAll': (props) => SugarList.insertAll(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.setAll': (props) => SugarList.setAll(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.remove': (props) => SugarList.remove(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.removeAt': (props) => SugarList.removeAt(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.removeLast': (props) => SugarList.removeLast(
            props['pa'][0],
          ),
      'SugarList.removeWhere': (props) => SugarList.removeWhere(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.retainWhere': (props) => SugarList.retainWhere(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.adds': (props) => SugarList.adds(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarList.sublist': (props) => SugarList.sublist(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.getRange': (props) => SugarList.getRange(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.setRange': (props) => SugarList.setRange(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            props['pa'][3],
            props['pa'][4] ?? 0,
          ),
      'SugarList.removeRange': (props) => SugarList.removeRange(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarList.fillRange': (props) => SugarList.fillRange(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            props['pa'][3],
          ),
      'SugarList.replaceRange': (props) => SugarList.replaceRange(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            props['pa'][3],
          ),
      'SugarList.asMap': (props) => SugarList.asMap(
            props['pa'][0],
          ),
      'SugarList.equalTo': (props) => SugarList.equalTo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.isNaN': (props) => SugarNum.isNaN(
            props['pa'][0],
          ),
      'SugarNum.isNegative': (props) => SugarNum.isNegative(
            props['pa'][0],
          ),
      'SugarNum.isInfinite': (props) => SugarNum.isInfinite(
            props['pa'][0],
          ),
      'SugarNum.isFinite': (props) => SugarNum.isFinite(
            props['pa'][0],
          ),
      'SugarNum.sign': (props) => SugarNum.sign(
            props['pa'][0],
          ),
      'SugarNum.equalTo': (props) => SugarNum.equalTo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.compareTo': (props) => SugarNum.compareTo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.adds': (props) => SugarNum.adds(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.subtracts': (props) => SugarNum.subtracts(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.multiplies': (props) => SugarNum.multiplies(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.euclideanModulo': (props) => SugarNum.euclideanModulo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.divides': (props) => SugarNum.divides(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.truncatingDivision': (props) => SugarNum.truncatingDivision(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.negation': (props) => SugarNum.negation(
            props['pa'][0],
          ),
      'SugarNum.remainder': (props) => SugarNum.remainder(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.smallerThan': (props) => SugarNum.smallerThan(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.smallerThanOrEqualTo': (props) => SugarNum.smallerThanOrEqualTo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.greaterThan': (props) => SugarNum.greaterThan(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.greaterThanOrEqualTo': (props) => SugarNum.greaterThanOrEqualTo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.abs': (props) => SugarNum.abs(
            props['pa'][0],
          ),
      'SugarNum.round': (props) => SugarNum.round(
            props['pa'][0],
          ),
      'SugarNum.floor': (props) => SugarNum.floor(
            props['pa'][0],
          ),
      'SugarNum.ceil': (props) => SugarNum.ceil(
            props['pa'][0],
          ),
      'SugarNum.truncate': (props) => SugarNum.truncate(
            props['pa'][0],
          ),
      'SugarNum.roundToDouble': (props) => SugarNum.roundToDouble(
            props['pa'][0],
          ),
      'SugarNum.floorToDouble': (props) => SugarNum.floorToDouble(
            props['pa'][0],
          ),
      'SugarNum.ceilToDouble': (props) => SugarNum.ceilToDouble(
            props['pa'][0],
          ),
      'SugarNum.truncateToDouble': (props) => SugarNum.truncateToDouble(
            props['pa'][0],
          ),
      'SugarNum.clamp': (props) => SugarNum.clamp(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarNum.toInt': (props) => SugarNum.toInt(
            props['pa'][0],
          ),
      'SugarNum.toDouble': (props) => SugarNum.toDouble(
            props['pa'][0],
          ),
      'SugarNum.toStringAsFixed': (props) => SugarNum.toStringAsFixed(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.toStringAsExponential': (props) =>
          SugarNum.toStringAsExponential(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.toStringAsPrecision': (props) => SugarNum.toStringAsPrecision(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.numToString': (props) => SugarNum.numToString(
            props['pa'][0],
          ),
      'SugarNum.parse': (props) => SugarNum.parse(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarNum.tryParse': (props) => SugarNum.tryParse(
            props['pa'][0],
          ),
      'SugarString.length': (props) => SugarString.length(
            props['pa'][0],
          ),
      'SugarString.isEmpty': (props) => SugarString.isEmpty(
            props['pa'][0],
          ),
      'SugarString.isNotEmpty': (props) => SugarString.isNotEmpty(
            props['pa'][0],
          ),
      'SugarString.codeUnits': (props) => SugarString.codeUnits(
            props['pa'][0],
          ),
      'SugarString.runes': (props) => SugarString.runes(
            props['pa'][0],
          ),
      'SugarString.getChar': (props) => SugarString.getChar(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.codeUnitAt': (props) => SugarString.codeUnitAt(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.equalTo': (props) => SugarString.equalTo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.compareTo': (props) => SugarString.compareTo(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.endsWith': (props) => SugarString.endsWith(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.startsWith': (props) => SugarString.startsWith(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarString.indexOf': (props) => SugarString.indexOf(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarString.lastIndexOf': (props) => SugarString.lastIndexOf(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarString.concatenates': (props) => SugarString.concatenates(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.substring': (props) => SugarString.substring(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarString.trim': (props) => SugarString.trim(
            props['pa'][0],
          ),
      'SugarString.trimLeft': (props) => SugarString.trimLeft(
            props['pa'][0],
          ),
      'SugarString.trimRight': (props) => SugarString.trimRight(
            props['pa'][0],
          ),
      'SugarString.multipliedConcatenates': (props) =>
          SugarString.multipliedConcatenates(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.padLeft': (props) => SugarString.padLeft(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? ' ',
          ),
      'SugarString.padRight': (props) => SugarString.padRight(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? ' ',
          ),
      'SugarString.contains': (props) => SugarString.contains(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2] ?? 0,
          ),
      'SugarString.replaceFirst': (props) => SugarString.replaceFirst(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            props['pa'][3] ?? 0,
          ),
      'SugarString.replaceFirstMapped': (props) =>
          SugarString.replaceFirstMapped(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            props['pa'][3] ?? 0,
          ),
      'SugarString.replaceAll': (props) => SugarString.replaceAll(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarString.replaceAllMapped': (props) => SugarString.replaceAllMapped(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
          ),
      'SugarString.replaceRange': (props) => SugarString.replaceRange(
            props['pa'][0],
            props['pa'][1],
            props['pa'][2],
            props['pa'][3],
          ),
      'SugarString.split': (props) => SugarString.split(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarString.splitMapJoin': (props) => SugarString.splitMapJoin(
            props['pa'][0],
            props['pa'][1],
            onMatch: props['onMatch'],
            onNonMatch: props['onNonMatch'],
          ),
      'SugarString.toLowerCase': (props) => SugarString.toLowerCase(
            props['pa'][0],
          ),
      'SugarString.toUpperCase': (props) => SugarString.toUpperCase(
            props['pa'][0],
          ),
      'SugarCommon.pullToRefreshContainerBuilder': (props) =>
          SugarCommon.pullToRefreshContainerBuilder(
            props['pa'][0],
          ),
      'SugarCommon.onImageStateChanged': (props) =>
          SugarCommon.onImageStateChanged(
            props['pa'][0],
          ),
      'SugarCommon.colorComputeLuminance': (props) =>
          SugarCommon.colorComputeLuminance(
            props['pa'][0],
          ),
      'SugarCommon.getRandomColor': (props) => SugarCommon.getRandomColor(
            props['pa'][0],
          ),
      'SugarCommon.getLuminanceColor': (props) => SugarCommon.getLuminanceColor(
            props['pa'][0]?.toDouble(),
          ),
      'SugarCommon.likeButtonTapCallback': (props) =>
          SugarCommon.likeButtonTapCallback(
            props['pa'][0],
            index: props['index'],
          ),
      'SugarCommon.voidCallBack': (props) => SugarCommon.voidCallBack(
            function: props['function'],
            value: props['value'],
          ),
      'SugarCommon.onSlidingPage': (props) => SugarCommon.onSlidingPage(
            props['pa'][0],
          ),
      'SugarCommon.loadingMoreIndicatorBuilder': (props) =>
          SugarCommon.loadingMoreIndicatorBuilder(
            props['pa'][0],
            tryAgain: props['tryAgain'],
            text: props['text'],
            backgroundColor: props['backgroundColor'],
            isSliver: props['isSliver'] ?? false,
            emptyWidget: props['emptyWidget'],
          ),
      'SugarCommon.loadingMoreItemBuilder': (props) =>
          SugarCommon.loadingMoreItemBuilder(
            props['pa'][0],
          ),
      'SugarCommon.nullOrDefault': (props) => SugarCommon.nullOrDefault(
            props['pa'][0],
            props['pa'][1],
          ),
      'SugarStringExtension.test': (props) => SugarStringExtension.test(
            props['pa'][0],
          ),
      'ExtendedFairWidget': (props) => ExtendedFairWidget(
            key: props['key'],
            builder: props['builder'],
            name: props['name'],
            fairProps: props['fairProps'],
            delegate: props['delegate'],
            holder: props['holder'],
            wantKeepAlive: props['wantKeepAlive'],
            index: props['index'],
          ),
      'ExtendedFairWidget.tag': ExtendedFairWidget.tag,
      'ExtendedFairWidget.fairEnable': (props) => ExtendedFairWidget.fairEnable(
            props['pa'][0],
          ),
      'ImageGrid': (props) => ImageGrid(
            key: props['key'],
            images: as<Widget>(props['images']) ?? const [],
            crossAxisCount: props['crossAxisCount'],
            mainAxisSpacing: props['mainAxisSpacing']?.toDouble() ?? 0.0,
            crossAxisSpacing: props['crossAxisSpacing']?.toDouble() ?? 0.0,
            padding: props['padding'],
            totalCount: props['totalCount'],
          ),
      'ImageGrid1': (props) => ImageGrid1(
            key: props['key'],
            images: as<dynamic>(props['images']) ?? const [],
            mainAxisSpacing: props['mainAxisSpacing']?.toDouble() ?? 0.0,
            crossAxisSpacing: props['crossAxisSpacing']?.toDouble() ?? 0.0,
            padding: props['padding'],
            onImageTap: props['onImageTap'],
          ),
      'HeroWidget': (props) => HeroWidget(
            key: props['key'],
            child: props['child'],
            tag: props['tag'],
            slidePagekey: props['slidePagekey'],
            slideType: props['slideType'] ?? SlideType.onlyImage,
          ),
      'ExtendedFrameSeparateWidget': (props) => ExtendedFrameSeparateWidget(
            key: props['key'],
            index: props['index'],
            placeHolder: props['placeHolder'],
            builder: props['builder'],
          ),
      'PullToRefreshHeader': (props) => PullToRefreshHeader(
            props['pa'][0],
            props['pa'][1],
            key: props['key'],
            color: props['color'],
          ),
      'RefreshImage': (props) => RefreshImage(
            props['pa'][0]?.toDouble(),
            key: props['key'],
          ),
      'ShareDataWidget': (props) => ShareDataWidget(
            key: props['key'],
            child: props['child'],
            data: props['data'],
            index: props['index'],
          ),
      'ShareDataWidget.of': (props) => ShareDataWidget.of(
            props['pa'][0],
          ),
      'ShareDataWidget.getIndex': (props) => ShareDataWidget.getIndex(
            props['pa'][0],
          ),
      'ShareDataWidget.getValue': (props) => ShareDataWidget.getValue(
            props['pa'][0],
            props['pa'][1],
            defaultValue: props['defaultValue'],
          ),
      'LoadingMoreRepository.onLoadData': (props) =>
          LoadingMoreRepository.onLoadData(
            props['pa'][0],
            props['pa'][1],
            notifyStateChanged: props['notifyStateChanged'],
            maxLength: props['maxLength'],
          ),
      'LoadingMoreSliverList': (props) => LoadingMoreSliverList(
            props['pa'][0],
            key: props['key'],
          ),
      'LoadingMoreCustomScrollView': (props) => LoadingMoreCustomScrollView(
            key: props['key'],
            scrollDirection: props['scrollDirection'] ?? Axis.vertical,
            reverse: props['reverse'] ?? false,
            controller: props['controller'],
            primary: props['primary'],
            physics: props['physics'],
            shrinkWrap: props['shrinkWrap'] ?? false,
            cacheExtent: props['cacheExtent']?.toDouble(),
            slivers: as<Widget>(props['slivers']) ?? const <Widget>[],
            semanticChildCount: props['semanticChildCount'],
            showGlowLeading: props['showGlowLeading'] ?? true,
            showGlowTrailing: props['showGlowTrailing'] ?? true,
            onScrollNotification: props['onScrollNotification'],
            dragStartBehavior:
                props['dragStartBehavior'] ?? DragStartBehavior.start,
            keyboardDismissBehavior: props['keyboardDismissBehavior'] ??
                ScrollViewKeyboardDismissBehavior.manual,
            restorationId: props['restorationId'],
            clipBehavior: props['clipBehavior'] ?? Clip.hardEdge,
            configs: as<SliverListConfig>(props['configs']),
            preloadExtent: props['preloadExtent']?.toDouble() ?? 0,
          ),
      'EmptyWidget': (props) => EmptyWidget(
            props['pa'][0],
            emptyWidget: props['emptyWidget'],
          ),
      'LoadingMoreList': (props) => LoadingMoreList(
            props['pa'][0],
            key: props['key'],
            onScrollNotification: props['onScrollNotification'],
          ),
      'IndicatorWidget': (props) => IndicatorWidget(
            props['pa'][0],
            tryAgain: props['tryAgain'],
            text: props['text'],
            backgroundColor: props['backgroundColor'],
            isSliver: props['isSliver'] ?? false,
            emptyWidget: props['emptyWidget'],
          ),
      'GlowNotificationWidget': (props) => GlowNotificationWidget(
            props['pa'][0],
            showGlowLeading: props['showGlowLeading'] ?? false,
            showGlowTrailing: props['showGlowTrailing'] ?? false,
          ),
      'ItemSizeInfoNotifier': (props) => ItemSizeInfoNotifier(
            key: props['key'],
            index: props['index'],
            child: props['child'],
          ),
      'FrameSeparateWidget': (props) => FrameSeparateWidget(
            key: props['key'],
            index: props['index'],
            placeHolder: props['placeHolder'],
            child: props['child'],
          ),
      'SizeCacheWidget': (props) => SizeCacheWidget(
            key: props['key'],
            child: props['child'],
            estimateCount: props['estimateCount'] ?? 0,
          ),
      'SizeCacheWidget.of': (props) => SizeCacheWidget.of(
            props['pa'][0],
          ),
      'LikeButton': (props) => LikeButton(
            key: props['key'],
            size: props['size']?.toDouble() ?? 30.0,
            likeBuilder: props['likeBuilder'],
            countBuilder: props['countBuilder'],
            bubblesSize: props['bubblesSize']?.toDouble(),
            circleSize: props['circleSize']?.toDouble(),
            likeCount: props['likeCount'],
            isLiked: props['isLiked'] ?? false,
            mainAxisAlignment:
                props['mainAxisAlignment'] ?? MainAxisAlignment.center,
            crossAxisAlignment:
                props['crossAxisAlignment'] ?? CrossAxisAlignment.center,
            animationDuration: props['animationDuration'] ??
                const Duration(milliseconds: 1000),
            likeCountAnimationType:
                props['likeCountAnimationType'] ?? LikeCountAnimationType.part,
            likeCountAnimationDuration: props['likeCountAnimationDuration'] ??
                const Duration(milliseconds: 500),
            likeCountPadding:
                props['likeCountPadding'] ?? const EdgeInsets.only(left: 3.0),
            bubblesColor: props['bubblesColor'] ??
                const BubblesColor(
                    dotPrimaryColor: Color(0xFFFFC107),
                    dotSecondaryColor: Color(0xFFFF9800),
                    dotThirdColor: Color(0xFFFF5722),
                    dotLastColor: Color(0xFFF44336)),
            circleColor: props['circleColor'] ??
                const CircleColor(
                    start: Color(0xFFFF5722), end: Color(0xFFFFC107)),
            onTap: props['onTap'],
            countPostion: props['countPostion'] ?? CountPostion.right,
            padding: props['padding'],
            countDecoration: props['countDecoration'],
            postFrameCallback: props['postFrameCallback'],
          ),
      'LikeCountAnimationType': {
        'none': LikeCountAnimationType.none,
        'part': LikeCountAnimationType.part,
        'all': LikeCountAnimationType.all,
        'values': LikeCountAnimationType.values,
      },
      'CountPostion': {
        'left': CountPostion.left,
        'right': CountPostion.right,
        'top': CountPostion.top,
        'bottom': CountPostion.bottom,
        'values': CountPostion.values,
      },
      'ToastPosition': {
        'center': ToastPosition.center,
        'bottom': ToastPosition.bottom,
        'top': ToastPosition.top,
      },
      'IndicatorStatus': {
        'none': IndicatorStatus.none,
        'loadingMoreBusying': IndicatorStatus.loadingMoreBusying,
        'fullScreenBusying': IndicatorStatus.fullScreenBusying,
        'error': IndicatorStatus.error,
        'fullScreenError': IndicatorStatus.fullScreenError,
        'noMoreLoad': IndicatorStatus.noMoreLoad,
        'empty': IndicatorStatus.empty,
        'values': IndicatorStatus.values,
      },
      'SliverPinnedPersistentHeader': (props) => SliverPinnedPersistentHeader(
            delegate: props['delegate'],
          ),
      'SliverPinnedPersistentHeaderRenderObjectWidget': (props) =>
          SliverPinnedPersistentHeaderRenderObjectWidget(
            props['pa'][0],
          ),
      'SliverPinnedToBoxAdapter': (props) => SliverPinnedToBoxAdapter(
            key: props['key'],
            child: props['child'],
          ),
      'SliverToNestedScrollBoxAdapter': (props) =>
          SliverToNestedScrollBoxAdapter(
            key: props['key'],
            child: props['child'],
            childExtent: props['childExtent']?.toDouble() ?? 0,
            onScrollOffsetChanged: props['onScrollOffsetChanged'],
          ),
      'ExtendedSliverAppbar': (props) => ExtendedSliverAppbar(
            leading: props['leading'],
            title: props['title'],
            actions: props['actions'],
            background: props['background'],
            toolBarColor: props['toolBarColor'],
            onBuild: props['onBuild'],
            statusbarHeight: props['statusbarHeight']?.toDouble(),
            toolbarHeight: props['toolbarHeight']?.toDouble(),
            isOpacityFadeWithToolbar: props['isOpacityFadeWithToolbar'] ?? true,
            isOpacityFadeWithTitle: props['isOpacityFadeWithTitle'] ?? true,
            mainAxisAlignment:
                props['mainAxisAlignment'] ?? MainAxisAlignment.spaceBetween,
            crossAxisAlignment:
                props['crossAxisAlignment'] ?? CrossAxisAlignment.center,
          ),
      'LoadState': {
        'loading': LoadState.loading,
        'completed': LoadState.completed,
        'failed': LoadState.failed,
        'values': LoadState.values,
      },
      'ExtendedImageMode': {
        'none': ExtendedImageMode.none,
        'gesture': ExtendedImageMode.gesture,
        'editor': ExtendedImageMode.editor,
        'values': ExtendedImageMode.values,
      },
      'ExtendedRawImage': (props) => ExtendedRawImage(
            key: props['key'],
            image: props['image'],
            width: props['width']?.toDouble(),
            height: props['height']?.toDouble(),
            scale: props['scale']?.toDouble() ?? 1.0,
            color: props['color'],
            opacity: props['opacity'],
            colorBlendMode: props['colorBlendMode'],
            fit: props['fit'],
            alignment: props['alignment'] ?? Alignment.center,
            repeat: props['repeat'] ?? ImageRepeat.noRepeat,
            centerSlice: props['centerSlice'],
            matchTextDirection: props['matchTextDirection'] ?? false,
            invertColors: props['invertColors'] ?? false,
            filterQuality: props['filterQuality'] ?? FilterQuality.low,
            sourceRect: props['sourceRect'],
            beforePaintImage: props['beforePaintImage'],
            afterPaintImage: props['afterPaintImage'],
            gestureDetails: props['gestureDetails'],
            editActionDetails: props['editActionDetails'],
            isAntiAlias: props['isAntiAlias'] ?? false,
            debugImageLabel: props['debugImageLabel'],
            layoutInsets: props['layoutInsets'] ?? EdgeInsets.zero,
          ),
      'ExtendedImageGesture': (props) => ExtendedImageGesture(
            props['pa'][0],
            imageBuilder: props['imageBuilder'],
            canScaleImage: props['canScaleImage'],
            key: props['key'],
          ),
      'InitialAlignment': {
        'topLeft': InitialAlignment.topLeft,
        'topCenter': InitialAlignment.topCenter,
        'topRight': InitialAlignment.topRight,
        'centerLeft': InitialAlignment.centerLeft,
        'center': InitialAlignment.center,
        'centerRight': InitialAlignment.centerRight,
        'bottomLeft': InitialAlignment.bottomLeft,
        'bottomCenter': InitialAlignment.bottomCenter,
        'bottomRight': InitialAlignment.bottomRight,
        'values': InitialAlignment.values,
      },
      'ActionType': {
        'zoom': ActionType.zoom,
        'pan': ActionType.pan,
        'edit': ActionType.edit,
        'values': ActionType.values,
      },
      'ExtendedImageSlidePage': (props) => ExtendedImageSlidePage(
            child: props['child'],
            slidePageBackgroundHandler: props['slidePageBackgroundHandler'],
            slideScaleHandler: props['slideScaleHandler'],
            slideOffsetHandler: props['slideOffsetHandler'],
            slideEndHandler: props['slideEndHandler'],
            slideAxis: props['slideAxis'] ?? SlideAxis.both,
            resetPageDuration:
                props['resetPageDuration'] ?? const Duration(milliseconds: 500),
            slideType: props['slideType'] ?? SlideType.onlyImage,
            onSlidingPage: props['onSlidingPage'],
            key: props['key'],
          ),
      'SlideAxis': {
        'both': SlideAxis.both,
        'horizontal': SlideAxis.horizontal,
        'vertical': SlideAxis.vertical,
        'values': SlideAxis.values,
      },
      'SlideType': {
        'wholePage': SlideType.wholePage,
        'onlyImage': SlideType.onlyImage,
        'values': SlideType.values,
      },
      'ExtendedImageSlidePageHandler': (props) => ExtendedImageSlidePageHandler(
            child: props['child'],
            extendedImageSlidePageState: props['extendedImageSlidePageState'],
            heroBuilderForSlidingPage: props['heroBuilderForSlidingPage'],
          ),
      'ExtendedImageGesturePageView': (props) => ExtendedImageGesturePageView(
            key: props['key'],
            scrollDirection: props['scrollDirection'] ?? Axis.horizontal,
            reverse: props['reverse'] ?? false,
            controller: props['controller'],
            physics: props['physics'],
            pageSnapping: props['pageSnapping'] ?? true,
            onPageChanged: props['onPageChanged'],
            children: as<Widget>(props['children']) ?? const <Widget>[],
            canScrollPage: props['canScrollPage'],
            preloadPagesCount: props['preloadPagesCount'] ?? 0,
          ),
      'ExtendedImageGesturePageView.builder': (props) =>
          ExtendedImageGesturePageView.builder(
            key: props['key'],
            scrollDirection: props['scrollDirection'] ?? Axis.horizontal,
            reverse: props['reverse'] ?? false,
            controller: props['controller'],
            physics: props['physics'],
            pageSnapping: props['pageSnapping'] ?? true,
            onPageChanged: props['onPageChanged'],
            itemBuilder: props['itemBuilder'],
            itemCount: props['itemCount'],
            canScrollPage: props['canScrollPage'],
            preloadPagesCount: props['preloadPagesCount'] ?? 0,
          ),
      'ExtendedImageGesturePageView.custom': (props) =>
          ExtendedImageGesturePageView.custom(
            key: props['key'],
            scrollDirection: props['scrollDirection'] ?? Axis.horizontal,
            reverse: props['reverse'] ?? false,
            controller: props['controller'],
            pageSnapping: props['pageSnapping'] ?? true,
            onPageChanged: props['onPageChanged'],
            canScrollPage: props['canScrollPage'],
            childrenDelegate: props['childrenDelegate'],
            preloadPagesCount: props['preloadPagesCount'] ?? 0,
          ),
      'ExtendedImageEditor': (props) => ExtendedImageEditor(
            extendedImageState: props['extendedImageState'],
            key: props['key'],
          ),
      'CropAspectRatios': {
        'custom': CropAspectRatios.custom,
        'original': CropAspectRatios.original,
        'ratio1_1': CropAspectRatios.ratio1_1,
        'ratio3_4': CropAspectRatios.ratio3_4,
        'ratio4_3': CropAspectRatios.ratio4_3,
        'ratio9_16': CropAspectRatios.ratio9_16,
        'ratio16_9': CropAspectRatios.ratio16_9,
      },
      'InitCropRectType': {
        'imageRect': InitCropRectType.imageRect,
        'layoutRect': InitCropRectType.layoutRect,
        'values': InitCropRectType.values,
      },
      'ExtendedImage': (props) => ExtendedImage(
            key: props['key'],
            image: props['image'],
            semanticLabel: props['semanticLabel'],
            excludeFromSemantics: props['excludeFromSemantics'] ?? false,
            width: props['width']?.toDouble(),
            height: props['height']?.toDouble(),
            color: props['color'],
            opacity: props['opacity'],
            colorBlendMode: props['colorBlendMode'],
            fit: props['fit'],
            alignment: props['alignment'] ?? Alignment.center,
            repeat: props['repeat'] ?? ImageRepeat.noRepeat,
            centerSlice: props['centerSlice'],
            matchTextDirection: props['matchTextDirection'] ?? false,
            gaplessPlayback: props['gaplessPlayback'] ?? false,
            filterQuality: props['filterQuality'] ?? FilterQuality.low,
            loadStateChanged: props['loadStateChanged'],
            border: props['border'],
            shape: props['shape'],
            borderRadius: props['borderRadius'],
            clipBehavior: props['clipBehavior'] ?? Clip.antiAlias,
            enableLoadState: props['enableLoadState'] ?? false,
            beforePaintImage: props['beforePaintImage'],
            afterPaintImage: props['afterPaintImage'],
            mode: props['mode'] ?? ExtendedImageMode.none,
            enableMemoryCache: props['enableMemoryCache'] ?? true,
            clearMemoryCacheIfFailed: props['clearMemoryCacheIfFailed'] ?? true,
            onDoubleTap: props['onDoubleTap'],
            initGestureConfigHandler: props['initGestureConfigHandler'],
            enableSlideOutPage: props['enableSlideOutPage'] ?? false,
            constraints: props['constraints'],
            extendedImageEditorKey: props['extendedImageEditorKey'],
            initEditorConfigHandler: props['initEditorConfigHandler'],
            heroBuilderForSlidingPage: props['heroBuilderForSlidingPage'],
            clearMemoryCacheWhenDispose:
                props['clearMemoryCacheWhenDispose'] ?? false,
            extendedImageGestureKey: props['extendedImageGestureKey'],
            isAntiAlias: props['isAntiAlias'] ?? false,
            handleLoadingProgress: props['handleLoadingProgress'] ?? false,
            layoutInsets: props['layoutInsets'] ?? EdgeInsets.zero,
          ),
      'ExtendedImage.asset': (props) => ExtendedImage.asset(
            props['pa'][0],
            key: props['key'],
            bundle: props['bundle'],
            semanticLabel: props['semanticLabel'],
            excludeFromSemantics: props['excludeFromSemantics'] ?? false,
            scale: props['scale']?.toDouble(),
            width: props['width']?.toDouble(),
            height: props['height']?.toDouble(),
            color: props['color'],
            opacity: props['opacity'],
            colorBlendMode: props['colorBlendMode'],
            fit: props['fit'],
            alignment: props['alignment'] ?? Alignment.center,
            repeat: props['repeat'] ?? ImageRepeat.noRepeat,
            centerSlice: props['centerSlice'],
            matchTextDirection: props['matchTextDirection'] ?? false,
            gaplessPlayback: props['gaplessPlayback'] ?? false,
            package: props['package'],
            filterQuality: props['filterQuality'] ?? FilterQuality.low,
            loadStateChanged: props['loadStateChanged'],
            shape: props['shape'],
            border: props['border'],
            borderRadius: props['borderRadius'],
            clipBehavior: props['clipBehavior'] ?? Clip.antiAlias,
            enableLoadState: props['enableLoadState'] ?? false,
            beforePaintImage: props['beforePaintImage'],
            afterPaintImage: props['afterPaintImage'],
            mode: props['mode'] ?? ExtendedImageMode.none,
            enableMemoryCache: props['enableMemoryCache'] ?? true,
            clearMemoryCacheIfFailed: props['clearMemoryCacheIfFailed'] ?? true,
            onDoubleTap: props['onDoubleTap'],
            initGestureConfigHandler: props['initGestureConfigHandler'],
            enableSlideOutPage: props['enableSlideOutPage'] ?? false,
            constraints: props['constraints'],
            extendedImageEditorKey: props['extendedImageEditorKey'],
            initEditorConfigHandler: props['initEditorConfigHandler'],
            heroBuilderForSlidingPage: props['heroBuilderForSlidingPage'],
            clearMemoryCacheWhenDispose:
                props['clearMemoryCacheWhenDispose'] ?? false,
            extendedImageGestureKey: props['extendedImageGestureKey'],
            cacheWidth: props['cacheWidth'],
            cacheHeight: props['cacheHeight'],
            isAntiAlias: props['isAntiAlias'] ?? false,
            compressionRatio: props['compressionRatio']?.toDouble(),
            maxBytes: props['maxBytes'],
            cacheRawData: props['cacheRawData'] ?? false,
            imageCacheName: props['imageCacheName'],
            layoutInsets: props['layoutInsets'] ?? EdgeInsets.zero,
          ),
      'ExtendedImage.file': (props) => ExtendedImage.file(
            props['pa'][0],
            key: props['key'],
            scale: props['scale']?.toDouble() ?? 1.0,
            semanticLabel: props['semanticLabel'],
            excludeFromSemantics: props['excludeFromSemantics'] ?? false,
            width: props['width']?.toDouble(),
            height: props['height']?.toDouble(),
            color: props['color'],
            opacity: props['opacity'],
            colorBlendMode: props['colorBlendMode'],
            fit: props['fit'],
            alignment: props['alignment'] ?? Alignment.center,
            repeat: props['repeat'] ?? ImageRepeat.noRepeat,
            centerSlice: props['centerSlice'],
            matchTextDirection: props['matchTextDirection'] ?? false,
            gaplessPlayback: props['gaplessPlayback'] ?? false,
            filterQuality: props['filterQuality'] ?? FilterQuality.low,
            loadStateChanged: props['loadStateChanged'],
            shape: props['shape'],
            border: props['border'],
            borderRadius: props['borderRadius'],
            clipBehavior: props['clipBehavior'] ?? Clip.antiAlias,
            enableLoadState: props['enableLoadState'] ?? false,
            beforePaintImage: props['beforePaintImage'],
            afterPaintImage: props['afterPaintImage'],
            mode: props['mode'] ?? ExtendedImageMode.none,
            enableMemoryCache: props['enableMemoryCache'] ?? true,
            clearMemoryCacheIfFailed: props['clearMemoryCacheIfFailed'] ?? true,
            onDoubleTap: props['onDoubleTap'],
            initGestureConfigHandler: props['initGestureConfigHandler'],
            enableSlideOutPage: props['enableSlideOutPage'] ?? false,
            constraints: props['constraints'],
            extendedImageEditorKey: props['extendedImageEditorKey'],
            initEditorConfigHandler: props['initEditorConfigHandler'],
            heroBuilderForSlidingPage: props['heroBuilderForSlidingPage'],
            clearMemoryCacheWhenDispose:
                props['clearMemoryCacheWhenDispose'] ?? false,
            extendedImageGestureKey: props['extendedImageGestureKey'],
            cacheWidth: props['cacheWidth'],
            cacheHeight: props['cacheHeight'],
            isAntiAlias: props['isAntiAlias'] ?? false,
            compressionRatio: props['compressionRatio']?.toDouble(),
            maxBytes: props['maxBytes'],
            cacheRawData: props['cacheRawData'] ?? false,
            imageCacheName: props['imageCacheName'],
            layoutInsets: props['layoutInsets'] ?? EdgeInsets.zero,
          ),
      'ExtendedImage.memory': (props) => ExtendedImage.memory(
            props['pa'][0],
            key: props['key'],
            scale: props['scale']?.toDouble() ?? 1.0,
            semanticLabel: props['semanticLabel'],
            excludeFromSemantics: props['excludeFromSemantics'] ?? false,
            width: props['width']?.toDouble(),
            height: props['height']?.toDouble(),
            color: props['color'],
            opacity: props['opacity'],
            colorBlendMode: props['colorBlendMode'],
            fit: props['fit'],
            alignment: props['alignment'] ?? Alignment.center,
            repeat: props['repeat'] ?? ImageRepeat.noRepeat,
            centerSlice: props['centerSlice'],
            matchTextDirection: props['matchTextDirection'] ?? false,
            gaplessPlayback: props['gaplessPlayback'] ?? false,
            filterQuality: props['filterQuality'] ?? FilterQuality.low,
            loadStateChanged: props['loadStateChanged'],
            shape: props['shape'],
            border: props['border'],
            borderRadius: props['borderRadius'],
            clipBehavior: props['clipBehavior'] ?? Clip.antiAlias,
            enableLoadState: props['enableLoadState'] ?? false,
            beforePaintImage: props['beforePaintImage'],
            afterPaintImage: props['afterPaintImage'],
            mode: props['mode'] ?? ExtendedImageMode.none,
            enableMemoryCache: props['enableMemoryCache'] ?? true,
            clearMemoryCacheIfFailed: props['clearMemoryCacheIfFailed'] ?? true,
            onDoubleTap: props['onDoubleTap'],
            initGestureConfigHandler: props['initGestureConfigHandler'],
            enableSlideOutPage: props['enableSlideOutPage'] ?? false,
            constraints: props['constraints'],
            extendedImageEditorKey: props['extendedImageEditorKey'],
            initEditorConfigHandler: props['initEditorConfigHandler'],
            heroBuilderForSlidingPage: props['heroBuilderForSlidingPage'],
            clearMemoryCacheWhenDispose:
                props['clearMemoryCacheWhenDispose'] ?? false,
            extendedImageGestureKey: props['extendedImageGestureKey'],
            cacheWidth: props['cacheWidth'],
            cacheHeight: props['cacheHeight'],
            isAntiAlias: props['isAntiAlias'] ?? false,
            compressionRatio: props['compressionRatio']?.toDouble(),
            maxBytes: props['maxBytes'],
            cacheRawData: props['cacheRawData'] ?? false,
            imageCacheName: props['imageCacheName'],
            layoutInsets: props['layoutInsets'] ?? EdgeInsets.zero,
          ),
      'ExtendedImage.network': (props) => ExtendedImage.network(
            props['pa'][0],
            key: props['key'],
            semanticLabel: props['semanticLabel'],
            excludeFromSemantics: props['excludeFromSemantics'] ?? false,
            width: props['width']?.toDouble(),
            height: props['height']?.toDouble(),
            color: props['color'],
            opacity: props['opacity'],
            colorBlendMode: props['colorBlendMode'],
            fit: props['fit'],
            alignment: props['alignment'] ?? Alignment.center,
            repeat: props['repeat'] ?? ImageRepeat.noRepeat,
            centerSlice: props['centerSlice'],
            matchTextDirection: props['matchTextDirection'] ?? false,
            gaplessPlayback: props['gaplessPlayback'] ?? false,
            filterQuality: props['filterQuality'] ?? FilterQuality.low,
            loadStateChanged: props['loadStateChanged'],
            shape: props['shape'],
            border: props['border'],
            borderRadius: props['borderRadius'],
            clipBehavior: props['clipBehavior'] ?? Clip.antiAlias,
            enableLoadState: props['enableLoadState'] ?? true,
            beforePaintImage: props['beforePaintImage'],
            afterPaintImage: props['afterPaintImage'],
            mode: props['mode'] ?? ExtendedImageMode.none,
            enableMemoryCache: props['enableMemoryCache'] ?? true,
            clearMemoryCacheIfFailed: props['clearMemoryCacheIfFailed'] ?? true,
            onDoubleTap: props['onDoubleTap'],
            initGestureConfigHandler: props['initGestureConfigHandler'],
            enableSlideOutPage: props['enableSlideOutPage'] ?? false,
            constraints: props['constraints'],
            cancelToken: props['cancelToken'],
            retries: props['retries'] ?? 3,
            timeLimit: props['timeLimit'],
            headers: props['headers'],
            cache: props['cache'] ?? true,
            scale: props['scale']?.toDouble() ?? 1.0,
            timeRetry: props['timeRetry'] ?? const Duration(milliseconds: 100),
            extendedImageEditorKey: props['extendedImageEditorKey'],
            initEditorConfigHandler: props['initEditorConfigHandler'],
            heroBuilderForSlidingPage: props['heroBuilderForSlidingPage'],
            clearMemoryCacheWhenDispose:
                props['clearMemoryCacheWhenDispose'] ?? false,
            handleLoadingProgress: props['handleLoadingProgress'] ?? false,
            extendedImageGestureKey: props['extendedImageGestureKey'],
            cacheWidth: props['cacheWidth'],
            cacheHeight: props['cacheHeight'],
            isAntiAlias: props['isAntiAlias'] ?? false,
            cacheKey: props['cacheKey'],
            printError: props['printError'] ?? true,
            compressionRatio: props['compressionRatio']?.toDouble(),
            maxBytes: props['maxBytes'],
            cacheRawData: props['cacheRawData'] ?? false,
            imageCacheName: props['imageCacheName'],
            cacheMaxAge: props['cacheMaxAge'],
            layoutInsets: props['layoutInsets'] ?? EdgeInsets.zero,
          ),
    };
  }

  @override
  Map<String, bool> mapping() {
    return const {
      'PullToRefreshNotification': true,
      'PullToRefreshContainer': true,
      'PullToRefreshCupertinoActivityIndicator': true,
      'PullToRefreshIndicatorMode': false,
      'TextOverflowWidget': true,
      'TextOverflowAlign': false,
      'TextOverflowPosition': false,
      'TextOverflowClearType': false,
      'ExtendedText': true,
      'ExtendedTextSelection': true,
      'ExtendedTextSelectionPointerHandler': true,
      'Assets': false,
      'SugarIterable': false,
      'SugarMap': false,
      'SugarBool': false,
      'SugarDouble': false,
      'SugarInt': false,
      'SugarList': false,
      'SugarNum': false,
      'SugarString': false,
      'SugarCommon': false,
      'SugarStringExtension': false,
      'ExtendedFairWidget': true,
      'ImageGrid': true,
      'ImageGrid1': true,
      'HeroWidget': true,
      'ExtendedFrameSeparateWidget': true,
      'PullToRefreshHeader': true,
      'RefreshImage': true,
      'ShareDataWidget': true,
      'LoadingMoreRepository': false,
      'LoadingMoreSliverList': true,
      'LoadingMoreCustomScrollView': true,
      'EmptyWidget': true,
      'LoadingMoreList': true,
      'IndicatorWidget': true,
      'GlowNotificationWidget': true,
      'ItemSizeInfoNotifier': true,
      'FrameSeparateWidget': true,
      'SizeCacheWidget': true,
      'LikeButton': true,
      'LikeCountAnimationType': false,
      'CountPostion': false,
      'ToastPosition': false,
      'IndicatorStatus': false,
      'SliverPinnedPersistentHeader': true,
      'SliverPinnedPersistentHeaderRenderObjectWidget': true,
      'SliverPinnedToBoxAdapter': true,
      'SliverToNestedScrollBoxAdapter': true,
      'ExtendedSliverAppbar': true,
      'LoadState': false,
      'ExtendedImageMode': false,
      'ExtendedRawImage': true,
      'ExtendedImageGesture': true,
      'InitialAlignment': false,
      'ActionType': false,
      'ExtendedImageSlidePage': true,
      'SlideAxis': false,
      'SlideType': false,
      'ExtendedImageSlidePageHandler': true,
      'ExtendedImageGesturePageView': true,
      'ExtendedImageEditor': true,
      'CropAspectRatios': false,
      'InitCropRectType': false,
      'ExtendedImage': true,
    };
  }
}
